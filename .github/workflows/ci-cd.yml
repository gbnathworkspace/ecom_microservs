name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      checks: write
      pull-requests: write
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Run tests
      env:
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb
        SPRING_DATASOURCE_USERNAME: testuser
        SPRING_DATASOURCE_PASSWORD: testpassword
      run: mvn clean test
    
    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Maven Tests
        path: '**/target/surefire-reports/*.xml'
        reporter: java-junit

  build:
    needs: test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, notification-service]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Build ${{ matrix.service }}
      run: |
        cd ${{ matrix.service }}
        mvn clean package -DskipTests
    
    - name: Build Docker image for ${{ matrix.service }}
      run: |
        cd ${{ matrix.service }}
        docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }} .
        docker tag ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }} ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:latest
    
    - name: Log in to Docker Hub
      if: github.ref == 'refs/heads/main'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Push Docker images
      if: github.ref == 'refs/heads/main'
      run: |
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }}
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy Microservices to EC2 via SSH
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        timeout: 180s
        script: |
          # Create docker-compose.yml on server
          cat > docker-compose.prod.yml << 'EOF'
          version: '3.8'
          services:
            postgres:
              image: postgres:13
              container_name: ecom-postgres
              environment:
                POSTGRES_DB: ecomdb
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              ports:
                - "5432:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - ecom-network
                
            user-service:
              image: ${{ secrets.DOCKER_USERNAME }}/user-service:latest
              container_name: ecom-user-service
              ports:
                - "8081:8081"
              environment:
                SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/ecomdb
                SPRING_DATASOURCE_USERNAME: postgres
                SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
                SPRING_PROFILES_ACTIVE: docker
              depends_on:
                - postgres
              networks:
                - ecom-network
                
            notification-service:
              image: ${{ secrets.DOCKER_USERNAME }}/notification-service:latest
              container_name: ecom-notification-service
              ports:
                - "8082:8082"
              environment:
                SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/ecomdb
                SPRING_DATASOURCE_USERNAME: postgres
                SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
                SPRING_PROFILES_ACTIVE: docker
              depends_on:
                - postgres
              networks:
                - ecom-network
                
            nginx:
              image: nginx:alpine
              container_name: ecom-load-balancer
              ports:
                - "80:80"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf
              depends_on:
                - user-service
                - notification-service
              networks:
                - ecom-network
                
          volumes:
            postgres_data:
            
          networks:
            ecom-network:
              driver: bridge
          EOF
          
          # Create nginx config
          cat > nginx.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          http {
              upstream user_service {
                  server user-service:8081;
              }
              upstream notification_service {
                  server notification-service:8082;
              }
              server {
                  listen 80;
                  location /api/users/ {
                      proxy_pass http://user_service/;
                  }
                  location /api/notifications/ {
                      proxy_pass http://notification_service/;
                  }
                  location /health {
                      return 200 'OK';
                  }
              }
          }
          EOF
          
          # Pull latest images
          docker pull ${{ secrets.DOCKER_USERNAME }}/user-service:latest
          docker pull ${{ secrets.DOCKER_USERNAME }}/notification-service:latest
          
          # Stop existing services
          docker-compose -f docker-compose.prod.yml down || true
          
          # Start all services
          docker-compose -f docker-compose.prod.yml up -d
          
          # Wait for services to start
          sleep 60
          
          # Health checks
          echo "Checking user-service health..."
          curl -f http://localhost:8081/actuator/health || echo "User service health check failed"
          
          echo "Checking notification-service health..."  
          curl -f http://localhost:8082/actuator/health || echo "Notification service health check failed"
          
          echo "Checking nginx load balancer..."
          curl -f http://localhost:80/health || echo "Load balancer health check failed"