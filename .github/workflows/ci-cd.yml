name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      checks: write
      pull-requests: write
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Run tests
      env:
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb
        SPRING_DATASOURCE_USERNAME: testuser
        SPRING_DATASOURCE_PASSWORD: testpassword
      run: mvn clean test
    
    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Maven Tests
        path: '**/target/surefire-reports/*.xml'
        reporter: java-junit

  build:
    needs: test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, notification-service, product-service]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image for ${{ matrix.service }}
      run: |
        docker build -f ${{ matrix.service }}/Dockerfile -t ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }} .
        docker tag ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }} ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:latest
    
    - name: Log in to Docker Hub
      if: github.ref == 'refs/heads/main'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Push Docker images
      if: github.ref == 'refs/heads/main'
      run: |
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ github.sha }}
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:latest



  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy Microservices to EC2 via SSH
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        timeout: 180s
        script: |
          # Create docker-compose.yml on server
          cat > docker-compose.prod.yml << 'EOF'
          version: '3.8'
          services:
            postgres:
              image: postgres:13
              container_name: ecom-postgres
              environment:
                POSTGRES_DB: ecomdb
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              ports:
                - "5432:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - ecom-network
              deploy:
                resources:
                  limits:
                    cpus: '0.5'
                    memory: 192M
                
            user-service:
              image: ${{ secrets.DOCKER_USERNAME }}/user-service:latest
              container_name: ecom-user-service
              ports:
                - "8081:8081"
              environment:
                SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/ecomdb
                SPRING_DATASOURCE_USERNAME: postgres
                SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
                SPRING_PROFILES_ACTIVE: docker
              depends_on:
                - postgres
              networks:
                - ecom-network
              deploy:
                resources:
                  limits:
                    cpus: '0.5'
                    memory: 192M

            notification-service:
              image: ${{ secrets.DOCKER_USERNAME }}/notification-service:latest
              container_name: ecom-notification-service
              ports:
                - "8082:8082"
              environment:
                SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/ecomdb
                SPRING_DATASOURCE_USERNAME: postgres
                SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
                SPRING_PROFILES_ACTIVE: docker
              depends_on:
                - postgres
              networks:
                - ecom-network
              deploy:
                resources:
                  limits:
                    cpus: '0.5'
                    memory: 192M

            product-service:
              image: ${{ secrets.DOCKER_USERNAME }}/product-service:latest
              container_name: ecom-product-service
              ports:
                - "8083:8083"
              environment:
                SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/ecomdb
                SPRING_DATASOURCE_USERNAME: postgres
                SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
                SPRING_PROFILES_ACTIVE: docker
              depends_on:
                - postgres
              networks:
                - ecom-network
              deploy:
                resources:
                  limits:
                    cpus: '0.5'
                    memory: 192M

            nginx:
              image: nginx:alpine
              container_name: ecom-load-balancer
              ports:
                - "80:80"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf
              depends_on:
                - user-service
                - notification-service
                - product-service
              networks:
                - ecom-network
              deploy:
                resources:
                  limits:
                    cpus: '0.5'
                    memory: 64M
                
          volumes:
            postgres_data:
            
          networks:
            ecom-network:
              driver: bridge
          EOF
          
          # Create nginx config
          cat > nginx.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          http {
              upstream user_service {
                  server user-service:8081;
              }
              upstream notification_service {
                  server notification-service:8082;
              }
              upstream product_service {
                  server product-service:8083;
              }
              server {
                  listen 80;
                  location /api/users/ {
                      proxy_pass http://user_service/;
                  }
                  location /api/notifications/ {
                      proxy_pass http://notification_service/;
                  }
                  location /api/products/ {
                      proxy_pass http://product_service/;
                  }
                  location /health {
                      return 200 'OK';
                  }
              }
          }
          EOF
          
          # Install docker-compose if not present
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            echo "docker-compose installed successfully"
          fi

          # Pull latest images
          docker pull ${{ secrets.DOCKER_USERNAME }}/user-service:latest
          docker pull ${{ secrets.DOCKER_USERNAME }}/notification-service:latest
          docker pull ${{ secrets.DOCKER_USERNAME }}/product-service:latest

          # Rolling deployment - restart one service at a time
          echo "Starting rolling deployment..."
        
          # Pull and restart postgres first
          docker-compose -f docker-compose.prod.yml up -d postgres
          sleep 20
          echo "Postgres restarted"
        
          # Restart user-service
          docker-compose -f docker-compose.prod.yml pull user-service
          docker-compose -f docker-compose.prod.yml up -d --no-deps user-service
          sleep 15
          echo "User service restarted"
        
          # Restart notification-service
          docker-compose -f docker-compose.prod.yml pull notification-service
          docker-compose -f docker-compose.prod.yml up -d --no-deps notification-service
          sleep 15
          echo "Notification service restarted"
        
          # Restart product-service
          docker-compose -f docker-compose.prod.yml pull product-service
          docker-compose -f docker-compose.prod.yml up -d --no-deps product-service
          sleep 15
          echo "Product service restarted"
        
          # Restart nginx last
          docker-compose -f docker-compose.prod.yml up -d --no-deps nginx
          echo "Rolling deployment complete"
          
          # Wait for services to start
          sleep 60
          
          # Health checks
          echo "Checking user-service health..."
          curl -f http://localhost:8081/dbhealth || echo "User service health check failed"
          
          echo "Checking notification-service health..."  
          curl -f http://localhost:8082/dbhealth || echo "Notification service health check failed"
          
          echo "Checking product-service health..."  
          curl -f http://localhost:8083/dbhealth || echo "Product service health check failed"
          
          echo "Checking nginx load balancer..."
          curl -f http://localhost:80/health || echo "Load balancer health check failed"